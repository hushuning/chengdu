<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>é™ä»·å• DAppï¼ˆBSC ç§æœ‰æŒ‚å•+åƒå•ï¼‰</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <h2>ğŸ“ åˆ›å»ºé™ä»·å•ï¼ˆBSCé“¾ï¼‰</h2>
  <form id="orderForm">
    <label>å–å‡ºä»£å¸åœ°å€ (makerToken):</label><br />
    <input type="text" id="makerToken" required><br />

    <label>ä¹°å…¥ä»£å¸åœ°å€ (takerToken):</label><br />
    <input type="text" id="takerToken" required><br />

    <label>å–å‡ºæ•°é‡:</label><br />
    <input type="text" id="makerAmount" required><br />

    <label>ä¹°å…¥æ•°é‡:</label><br />
    <input type="text" id="takerAmount" required><br /><br />

    <button type="submit">ğŸ“Œ ç­¾åå¹¶ä¿å­˜é™ä»·å•</button>
  </form>

  <h2>ğŸ“œ å·²æŒ‚å‡ºçš„é™ä»·å•</h2>
  <div id="orderList"></div>

  <p id="status"></p>

  <script>
    const LIMIT_ORDER_PROTOCOL = "0xc89b32a18ecced83c8393fd0de7df2d02ab86717"; // æ›¿æ¢ä¸ºä½ çš„åˆçº¦åœ°å€
    const orders = JSON.parse(localStorage.getItem('limitOrders') || '[]');
    const orderList = document.getElementById('orderList');
    const statusEl = document.getElementById('status');

    const renderOrders = () => {
      orderList.innerHTML = "";
      orders.forEach((o, i) => {
        const div = document.createElement('div');
        div.innerHTML = `
          <pre>${JSON.stringify(o.order, null, 2)}</pre>
          <button onclick="fillOrder(${i})">ğŸ¥© åƒæ‰è¿™å•</button>
          <hr />
        `;
        orderList.appendChild(div);
      });
    };

    renderOrders();

    document.getElementById('orderForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = provider.getSigner();
      const address = await signer.getAddress();

      const makerToken = document.getElementById('makerToken').value.trim();
      const takerToken = document.getElementById('takerToken').value.trim();
      const makerAmountRaw = document.getElementById('makerAmount').value.trim();
      const takerAmountRaw = document.getElementById('takerAmount').value.trim();

      const erc20 = new ethers.Contract(makerToken, ["function decimals() view returns (uint8)", "function allowance(address,address) view returns (uint256)", "function approve(address,uint256) returns (bool)"], signer);
      const decimals = await erc20.decimals();
      const makingAmount = ethers.utils.parseUnits(makerAmountRaw, decimals);
      const takingAmount = ethers.utils.parseUnits(takerAmountRaw, decimals);

      const allowance = await erc20.allowance(address, LIMIT_ORDER_PROTOCOL);
      if (allowance.lt(makingAmount)) {
        statusEl.innerText = "ğŸ” æ­£åœ¨æˆæƒ makerToken...";
        const tx = await erc20.approve(LIMIT_ORDER_PROTOCOL, ethers.constants.MaxUint256);
        await tx.wait();
        statusEl.innerText = "âœ… æˆæƒå®Œæˆï¼Œç»§ç»­ç”Ÿæˆé™ä»·å•...";
      }

      const salt = ethers.BigNumber.from(ethers.utils.randomBytes(32)).toString();
      const expiry = Math.floor(Date.now() / 1000) + 86400;

      const order = {
        makerToken,
        takerToken,
        makerAmount: makingAmount.toString(),
        takerAmount: takingAmount.toString(),
        takerTokenFeeAmount: "1",
        maker: address,
        taker: "0x0000000000000000000000000000000000000000",
        sender: "0x0000000000000000000000000000000000000000",
        feeRecipient: "0x99a190101E3FF57b258ae66243ED061Fc4AcbcE1",
        pool: "0x0000000000000000000000000000000000000000000000000000000000000000",
        expiry,
        salt
      };

      const network = await provider.getNetwork();
      const domain = {
        name: '0x Protocol',
        version: '4',
        chainId: network.chainId,
        verifyingContract: LIMIT_ORDER_PROTOCOL
      };

      const types = {
        LimitOrder: [
          { name: 'makerToken', type: 'address' },
          { name: 'takerToken', type: 'address' },
          { name: 'makerAmount', type: 'uint128' },
          { name: 'takerAmount', type: 'uint128' },
          { name: 'takerTokenFeeAmount', type: 'uint128' },
          { name: 'maker', type: 'address' },
          { name: 'taker', type: 'address' },
          { name: 'sender', type: 'address' },
          { name: 'feeRecipient', type: 'address' },
          { name: 'pool', type: 'bytes32' },
          { name: 'expiry', type: 'uint64' },
          { name: 'salt', type: 'uint256' }
        ]
      };

      const rawSignature = await signer._signTypedData(domain, types, order);
      const sig = ethers.utils.splitSignature(rawSignature);
      const fixedV = sig.v < 27 ? sig.v + 27 : sig.v;
      const signature = ethers.utils.joinSignature({ r: sig.r, s: sig.s, v: fixedV });

      const digest = ethers.utils._TypedDataEncoder.hash(domain, types, order);
      const recovered = ethers.utils.recoverAddress(digest, signature);
      console.log("âœ… Recovered signer:", recovered);
      console.log("ğŸ§¾ Expected maker:", order.maker);

      orders.push({ order, signature });
      localStorage.setItem('limitOrders', JSON.stringify(orders));
      statusEl.innerText = "âœ… é™ä»·å•å·²ç­¾åå¹¶ä¿å­˜ï¼";
      renderOrders();
    });

    async function fillOrder(index) {
      const { order, signature } = orders[index];
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = provider.getSigner();
      const taker = await signer.getAddress();

      const abi = [
        "function fillLimitOrder((address,address,uint128,uint128,uint128,address,address,address,address,bytes32,uint64,uint256),bytes,uint128) returns (uint128,uint128)",
        "function allowance(address owner, address spender) view returns (uint256)",
        "function balanceOf(address owner) view returns (uint256)",
        "function decimals() view returns (uint8)",
        "function approve(address,uint256) returns (bool)"
      ];

      const takerToken = new ethers.Contract(order.takerToken, abi, signer);
      const allowance = await takerToken.allowance(taker, LIMIT_ORDER_PROTOCOL);
      if (ethers.BigNumber.from(allowance).lt(order.takerAmount)) {
        statusEl.innerText = "ğŸ” æ­£åœ¨æˆæƒ takerToken...";
        const tx = await takerToken.approve(LIMIT_ORDER_PROTOCOL, ethers.constants.MaxUint256);
        await tx.wait();
        statusEl.innerText = "âœ… æˆæƒæˆåŠŸï¼Œç»§ç»­åƒå•...";
      }

      const orderTuple = [
        order.makerToken,
        order.takerToken,
        order.makerAmount,
        order.takerAmount,
        order.takerTokenFeeAmount,
        order.maker,
        order.taker,
        order.sender,
        order.feeRecipient,
        order.pool,
        order.expiry,
        order.salt
      ];

      const contract = new ethers.Contract(LIMIT_ORDER_PROTOCOL, abi, signer);
      try {
        const tx = await contract.fillLimitOrder(orderTuple, signature, order.takerAmount, { gasLimit: 800000 });
        statusEl.innerText = "â³ æ­£åœ¨åƒå•ä¸­...";
        await tx.wait();
        statusEl.innerText = `ğŸ‰ åƒå•æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œï¼š${tx.hash}`;
      } catch (err) {
        console.error(err);
        statusEl.innerText = "âŒ åƒå•å¤±è´¥ï¼š" + err.message;
      }
    }
  </script>
</body>
</html>
