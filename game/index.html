<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Room Explosion Game</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    body { margin: 0; padding: 0; }
    #game-container { width: 100vw; height: 100vh; overflow: hidden; }
    #game-container canvas { width: 100vw !important; height: 100vh !important; }
    #save-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      padding: 8px 12px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <button id="save-btn">打印坐标到控制台</button>

  <script>
    window.onload = function () {
      const DEV_MODE = false; // 设置为 true 以启用拖拽功能
      const ROOM_SCALE = 0.3;
      const GRID_COLS = 5;
      const GRID_ROWS = 2;

      const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        width: 800,
        height: 600,
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
        },
        scene: { preload, create, update }
      };

      const game = new Phaser.Game(config);
      let rooms = [];
      let betTexts = [];
      let bets = {};

      function preload() {
        this.load.image('background', 'assets/background.png');
        const roomFiles = [
          'room_asset_0.png', 'room_asset_62.png', 'room_asset_637.png',
          'room_asset_970.png', 'room_asset_1305.png', 'room_asset_1508.png',
          '7.png', '8.png', '9.png', '10.png'
        ];
        roomFiles.forEach((fn, idx) => {
          this.load.image('room' + idx, 'assets/room_assets/' + fn);
        });
        this.load.spritesheet('explosion', 'assets/explosion_spritesheet.png', { frameWidth: 64, frameHeight: 64 });
      }

      function create() {
        // 背景
        this.add.image(0, 0, 'background')
          .setOrigin(0)
          .setDisplaySize(config.width, config.height);

        // 初始位置
        const marginX = config.width * 0.1;
        const marginY = config.height * 0.3;
        const defaultPositions = calcPositions(config.width, config.height, GRID_COLS, GRID_ROWS, marginX, marginY);

        // 【手动写死坐标的位置】——每次拖拽后复制控制台输出的 const saved = [...] 并粘到这里：
        // const saved = null;
     const saved = [
  {
    "x": 114.8479873063484,
    "y": 163.9601987127388
  },
  {
    "x": 264.00639125548435,
    "y": 167.6616913174914
  },
  {
    "x": 417.8111935121337,
    "y": 165.19402958098962
  },
  {
    "x": 566.466951616793,
    "y": 151.05616741248457
  },
  {
    "x": 416.01335177458344,
    "y": 322.0106590514343
  },
  {
    "x": 95.25670989903574,
    "y": 296.0600023308948
  },
  {
    "x": 688.001546731329,
    "y": 461.3941824701993
  },
  {
    "x": 365.12300125041764,
    "y": 468.1594869397522
  },
  {
    "x": 693.9711511999615,
    "y": 173.2338263498273
  },
  {
    "x": 531.0694588239312,
    "y": 469.9990634902939
  }
];

        // 例如：
        // const saved = [
        //   { "x": 120, "y": 240 },
        //   { "x": 280, "y": 240 },
        //   ...
        // ];

        const positions = saved || defaultPositions;

        this.input.setTopOnly(true);

        positions.forEach((pos, idx) => {
          const sprite = this.add.image(pos.x, pos.y, 'room' + idx)
            .setScale(ROOM_SCALE)
            .setInteractive({ draggable: DEV_MODE });

          sprite.setData('idx', idx);
          let wasDragged = false;

          if (DEV_MODE) {
            sprite.on('dragstart', () => {
              wasDragged = true;
              sprite.setTint(0xaaaaaa);
            });
            sprite.on('drag', (pointer, dragX, dragY) => {
              sprite.x = dragX;
              sprite.y = dragY;
              betTexts[idx].setPosition(dragX, dragY - 40 * ROOM_SCALE);
            });
            sprite.on('dragend', () => {
              sprite.clearTint();
              // 拖拽结束后打印可粘回 HTML 的坐标代码
              const coords = rooms.map(r => ({ x: r.x, y: r.y }));
              console.log(
                'const saved = ' +
                JSON.stringify(coords, null, 2) +
                ';'
              );
              setTimeout(() => { wasDragged = false; }, 100);
            });
          }

          sprite.on('pointerup', () => {
            if (!wasDragged) onRoomClick(idx);
          });

          rooms.push(sprite);

          const text = this.add.text(pos.x, pos.y - 40 * ROOM_SCALE, bets[idx] ? `$${bets[idx]}` : '', {
            font: `${18 * ROOM_SCALE}px Arial`,
            fill: '#ffffff', stroke: '#000000', strokeThickness: 3
          }).setOrigin(0.5);
          betTexts.push(text);
        });

        this.anims.create({
          key: 'explode',
          frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: 9 }),
          frameRate: 15,
          hideOnComplete: true
        });

        this.add.text(20, 20, '开始一轮', { font: '20px Arial', fill: '#00ff00' })
          .setInteractive()
          .on('pointerdown', () => simulateRound.call(this));

        // “打印坐标”按钮也触发同样的打印
        document.getElementById('save-btn').addEventListener('click', () => {
          const coords = rooms.map(r => ({ x: r.x, y: r.y }));
          console.log(
            'const saved = ' +
            JSON.stringify(coords, null, 2) +
            ';'
          );
        });
      }

      function update() {}

      function onRoomClick(idx) {
        const amount = prompt(`为房间 ${idx + 1} 输入下注金额：`);
        if (amount) {
          bets[idx] = parseFloat(amount);
          betTexts[idx].setText(`$${bets[idx]}`);
        }
      }

      function simulateRound() {
        if (rooms.length < 2) return;
        const indices = Phaser.Utils.Array.NumberArray(0, rooms.length - 1);
        Phaser.Utils.Array.Shuffle(indices);
        indices.slice(0, 2).forEach(i => {
          const { x, y } = rooms[i];
          this.add.sprite(x, y, 'explosion')
            .setScale(ROOM_SCALE * 2)
            .play('explode');
        });
      }

      function calcPositions(w, h, cols, rows, marginX, marginY) {
        const arr = [];
        const stepX = (w - marginX * 2) / (cols - 1);
        const stepY = (h - marginY * 2) / (rows - 1);
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            arr.push({ x: marginX + stepX * i, y: marginY + stepY * j });
          }
        }
        return arr;
      }
    };
  </script>
</body>
</html>
