<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>é™ä»·å• DAppï¼ˆBSC ç§æœ‰æŒ‚å•+åƒå•ï¼‰</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <h2>ğŸ“ åˆ›å»ºé™ä»·å•ï¼ˆBSCé“¾ï¼‰</h2>
  <form id="orderForm">
    <label>å–å‡ºä»£å¸åœ°å€ (makerToken):</label><br />
    <input type="text" id="makerToken" required><br />

    <label>ä¹°å…¥ä»£å¸åœ°å€ (takerToken):</label><br />
    <input type="text" id="takerToken" required><br />

    <label>å–å‡ºæ•°é‡:</label><br />
    <input type="text" id="makerAmount" required><br />

    <label>ä¹°å…¥æ•°é‡:</label><br />
    <input type="text" id="takerAmount" required><br /><br />

    <button type="submit">ğŸ“Œ ç­¾åå¹¶ä¿å­˜é™ä»·å•</button>
  </form>

  <h2>ğŸ“œ å·²æŒ‚å‡ºçš„é™ä»·å•</h2>
  <div id="orderList"></div>

  <p id="status"></p>

  <script>
    const LIMIT_ORDER_PROTOCOL = "0x1111111254EEB25477B68fb85Ed929f73A960582";
    const orders = JSON.parse(localStorage.getItem('limitOrders') || '[]');
    const orderList = document.getElementById('orderList');
    const statusEl = document.getElementById('status');

    const renderOrders = () => {
      orderList.innerHTML = "";
      orders.forEach((o, i) => {
        const div = document.createElement('div');
        div.innerHTML = `
          <pre>${JSON.stringify(o.order, null, 2)}</pre>
          <button onclick="fillOrder(${i})">ğŸ¥© åƒæ‰è¿™å•</button>
          <hr />
        `;
        orderList.appendChild(div);
      });
    };

    renderOrders();

    document.getElementById('orderForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = provider.getSigner();
      const address = await signer.getAddress();

      const makerToken = document.getElementById('makerToken').value.trim();
      const takerToken = document.getElementById('takerToken').value.trim();
      const makerAmountRaw = document.getElementById('makerAmount').value.trim();
      const takerAmountRaw = document.getElementById('takerAmount').value.trim();

      const erc20 = new ethers.Contract(makerToken, ["function decimals() view returns (uint8)", "function allowance(address,address) view returns (uint256)", "function approve(address,uint256) returns (bool)"], signer);
      const decimals = await erc20.decimals();
      const makingAmount = ethers.utils.parseUnits(makerAmountRaw, decimals).toString();
      const takingAmount = ethers.utils.parseUnits(takerAmountRaw, decimals).toString();

      const allowance = await erc20.allowance(address, LIMIT_ORDER_PROTOCOL);
      if (ethers.BigNumber.from(allowance).lt(makingAmount)) {
        statusEl.innerText = "ğŸ” æ­£åœ¨æˆæƒ makerToken...";
        const tx = await erc20.approve(LIMIT_ORDER_PROTOCOL, ethers.constants.MaxUint256);
        await tx.wait();
        statusEl.innerText = "âœ… æˆæƒå®Œæˆï¼Œç»§ç»­ç”Ÿæˆé™ä»·å•...";
      }

      const salt = ethers.BigNumber.from(ethers.utils.randomBytes(32)).toString();
      const order = {
        salt,
        makerAsset: makerToken,
        takerAsset: takerToken,
        maker: address,
        receiver: address,
        allowedSender: "0x0000000000000000000000000000000000000000",
        makingAmount,
        takingAmount,
        offsets: "0x",
        interactions: "0x"
      };

      const network = await provider.getNetwork();
      const domain = {
        name: '1inch Limit Order Protocol',
        version: '3',
        chainId: network.chainId,
        verifyingContract: LIMIT_ORDER_PROTOCOL
      };

      const types = {
        Order: [
          { name: 'salt', type: 'uint256' },
          { name: 'makerAsset', type: 'address' },
          { name: 'takerAsset', type: 'address' },
          { name: 'maker', type: 'address' },
          { name: 'receiver', type: 'address' },
          { name: 'allowedSender', type: 'address' },
          { name: 'makingAmount', type: 'uint256' },
          { name: 'takingAmount', type: 'uint256' },
          { name: 'offsets', type: 'bytes' },
          { name: 'interactions', type: 'bytes' }
        ]
      };

      const rawSignature = await signer._signTypedData(domain, types, order);
      const sig = ethers.utils.splitSignature(rawSignature);
      const fixedV = sig.v < 27 ? sig.v + 27 : sig.v;
      const signature = ethers.utils.joinSignature({ r: sig.r, s: sig.s, v: fixedV });

      // éªŒè¯ç­¾åæ˜¯å¦å¯¹åº” maker
      const digest = ethers.utils._TypedDataEncoder.hash(domain, types, order);
      const recovered = ethers.utils.recoverAddress(digest, signature);
      console.log("âœ… Recovered signer:", recovered);
      console.log("ğŸ§¾ Expected maker:", order.maker);

      orders.push({ order, signature });
      localStorage.setItem('limitOrders', JSON.stringify(orders));
      statusEl.innerText = "âœ… é™ä»·å•å·²ç­¾åå¹¶ä¿å­˜ï¼";
      renderOrders();
    });

    async function fillOrder(index) {
      const { order, signature } = orders[index];
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = provider.getSigner();
      const taker = await signer.getAddress();

      const abi = [
        "function fillOrder(tuple(uint256,address,address,address,address,address,uint256,uint256,bytes,bytes), bytes, uint256) returns (uint256,uint256)",
        "function allowance(address owner, address spender) view returns (uint256)",
        "function balanceOf(address owner) view returns (uint256)",
        "function decimals() view returns (uint8)",
        "function approve(address,uint256) returns (bool)"
      ];

      const takerToken = new ethers.Contract(order.takerAsset, abi, signer);
      const allowance = await takerToken.allowance(taker, LIMIT_ORDER_PROTOCOL);
      if (ethers.BigNumber.from(allowance).lt(order.takingAmount)) {
        statusEl.innerText = "ğŸ” æ­£åœ¨æˆæƒ takerToken...";
        const tx = await takerToken.approve(LIMIT_ORDER_PROTOCOL, ethers.constants.MaxUint256);
        await tx.wait();
        statusEl.innerText = "âœ… æˆæƒæˆåŠŸï¼Œç»§ç»­åƒå•...";
      }

      const makerToken = new ethers.Contract(order.makerAsset, abi, provider);
      const makerBalance = await makerToken.balanceOf(order.maker);
      const makerAllowance = await makerToken.allowance(order.maker, LIMIT_ORDER_PROTOCOL);
      if (ethers.BigNumber.from(makerBalance).lt(order.makingAmount)) {
        statusEl.innerText = "âŒ maker ä½™é¢ä¸è¶³ï¼Œæ— æ³•åƒå•ã€‚";
        return;
      }
      if (ethers.BigNumber.from(makerAllowance).lt(order.makingAmount)) {
        statusEl.innerText = "âŒ maker æœªæˆæƒä»£å¸ï¼Œæ— æ³•åƒå•ã€‚";
        return;
      }

      const contract = new ethers.Contract(LIMIT_ORDER_PROTOCOL, abi, signer);
      const orderTuple = [
        order.salt,
        order.makerAsset,
        order.takerAsset,
        order.maker,
        order.receiver,
        order.allowedSender,
        order.makingAmount,
        order.takingAmount,
        order.offsets,
        order.interactions
      ];

      try {
        const tx = await contract.fillOrder(orderTuple, signature, order.takingAmount, { gasLimit: 500000 });
        statusEl.innerText = "â³ æ­£åœ¨åƒå•ä¸­...";
        await tx.wait();
        statusEl.innerText = `ğŸ‰ åƒå•æˆåŠŸï¼äº¤æ˜“å“ˆå¸Œï¼š${tx.hash}`;
      } catch (err) {
        console.error(err);
        statusEl.innerText = "âŒ åƒå•å¤±è´¥ï¼š" + err.message;
      }
    }
  </script>
</body>
</html>
